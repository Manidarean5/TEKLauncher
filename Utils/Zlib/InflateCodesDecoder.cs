using TEKLauncher.SteamInterop.Network;
using static System.Array;
using static TEKLauncher.Utils.Zlib.InflateBlocksDecoder;

namespace TEKLauncher.Utils.Zlib
{
    internal class InflateCodesDecoder
    {
        internal InflateCodesDecoder(InflateBlocksDecoder BlocksDecoder) => this.BlocksDecoder = BlocksDecoder;
        private int DBitsPerBranch, DTreeIndex, Distance, LBitsPerBranch, LTreeIndex, Length;
        private int[] DTree, LTree;
        private readonly InflateBlocksDecoder BlocksDecoder;
        private static readonly int[] FixedDTree = new[]
        {
            0x0050, 0x0005, 0x0001, 0x0057, 0x0005, 0x0101, 0x0053, 0x0005, 0x0011, 0x005B, 0x0005, 0x1001, 0x0051, 0x0005, 0x0005, 0x0059,
            0x0005, 0x0401, 0x0055, 0x0005, 0x0041, 0x005D, 0x0005, 0x4001, 0x0050, 0x0005, 0x0003, 0x0058, 0x0005, 0x0201, 0x0054, 0x0005,
            0x0021, 0x005C, 0x0005, 0x2001, 0x0052, 0x0005, 0x0009, 0x005A, 0x0005, 0x0801, 0x0056, 0x0005, 0x0081, 0x00C0, 0x0005, 0x6001,
            0x0050, 0x0005, 0x0002, 0x0057, 0x0005, 0x0181, 0x0053, 0x0005, 0x0019, 0x005B, 0x0005, 0x1801, 0x0051, 0x0005, 0x0007, 0x0059,
            0x0005, 0x0601, 0x0055, 0x0005, 0x0061, 0x005D, 0x0005, 0x6001, 0x0050, 0x0005, 0x0004, 0x0058, 0x0005, 0x0301, 0x0054, 0x0005,
            0x0031, 0x005C, 0x0005, 0x3001, 0x0052, 0x0005, 0x000D, 0x005A, 0x0005, 0x0C01, 0x0056, 0x0005, 0x00C1, 0x00C0, 0x0005, 0x6001
        },
        FixedLTree = new[]
        {
            0x060, 0x007, 0x100, 0x000, 0x008, 0x050, 0x000, 0x008, 0x010, 0x054, 0x008, 0x073, 0x052, 0x007, 0x01F, 0x000,
            0x008, 0x070, 0x000, 0x008, 0x030, 0x000, 0x009, 0x0C0, 0x050, 0x007, 0x00A, 0x000, 0x008, 0x060, 0x000, 0x008,
            0x020, 0x000, 0x009, 0x0A0, 0x000, 0x008, 0x000, 0x000, 0x008, 0x080, 0x000, 0x008, 0x040, 0x000, 0x009, 0x0E0,
            0x050, 0x007, 0x006, 0x000, 0x008, 0x058, 0x000, 0x008, 0x018, 0x000, 0x009, 0x090, 0x053, 0x007, 0x03B, 0x000,
            0x008, 0x078, 0x000, 0x008, 0x038, 0x000, 0x009, 0x0D0, 0x051, 0x007, 0x011, 0x000, 0x008, 0x068, 0x000, 0x008,
            0x028, 0x000, 0x009, 0x0B0, 0x000, 0x008, 0x008, 0x000, 0x008, 0x088, 0x000, 0x008, 0x048, 0x000, 0x009, 0x0F0,
            0x050, 0x007, 0x004, 0x000, 0x008, 0x054, 0x000, 0x008, 0x014, 0x055, 0x008, 0x0E3, 0x053, 0x007, 0x02B, 0x000,
            0x008, 0x074, 0x000, 0x008, 0x034, 0x000, 0x009, 0x0C8, 0x051, 0x007, 0x00D, 0x000, 0x008, 0x064, 0x000, 0x008,
            0x024, 0x000, 0x009, 0x0A8, 0x000, 0x008, 0x004, 0x000, 0x008, 0x084, 0x000, 0x008, 0x044, 0x000, 0x009, 0x0E8,
            0x050, 0x007, 0x008, 0x000, 0x008, 0x05C, 0x000, 0x008, 0x01C, 0x000, 0x009, 0x098, 0x054, 0x007, 0x053, 0x000,
            0x008, 0x07C, 0x000, 0x008, 0x03C, 0x000, 0x009, 0x0D8, 0x052, 0x007, 0x017, 0x000, 0x008, 0x06C, 0x000, 0x008,
            0x02C, 0x000, 0x009, 0x0B8, 0x000, 0x008, 0x00C, 0x000, 0x008, 0x08C, 0x000, 0x008, 0x04C, 0x000, 0x009, 0x0F8,
            0x050, 0x007, 0x003, 0x000, 0x008, 0x052, 0x000, 0x008, 0x012, 0x055, 0x008, 0x0A3, 0x053, 0x007, 0x023, 0x000,
            0x008, 0x072, 0x000, 0x008, 0x032, 0x000, 0x009, 0x0C4, 0x051, 0x007, 0x00B, 0x000, 0x008, 0x062, 0x000, 0x008,
            0x022, 0x000, 0x009, 0x0A4, 0x000, 0x008, 0x002, 0x000, 0x008, 0x082, 0x000, 0x008, 0x042, 0x000, 0x009, 0x0E4,
            0x050, 0x007, 0x007, 0x000, 0x008, 0x05A, 0x000, 0x008, 0x01A, 0x000, 0x009, 0x094, 0x054, 0x007, 0x043, 0x000,
            0x008, 0x07A, 0x000, 0x008, 0x03A, 0x000, 0x009, 0x0D4, 0x052, 0x007, 0x013, 0x000, 0x008, 0x06A, 0x000, 0x008,
            0x02A, 0x000, 0x009, 0x0B4, 0x000, 0x008, 0x00A, 0x000, 0x008, 0x08A, 0x000, 0x008, 0x04A, 0x000, 0x009, 0x0F4,
            0x050, 0x007, 0x005, 0x000, 0x008, 0x056, 0x000, 0x008, 0x016, 0x0C0, 0x008, 0x000, 0x053, 0x007, 0x033, 0x000,
            0x008, 0x076, 0x000, 0x008, 0x036, 0x000, 0x009, 0x0CC, 0x051, 0x007, 0x00F, 0x000, 0x008, 0x066, 0x000, 0x008,
            0x026, 0x000, 0x009, 0x0AC, 0x000, 0x008, 0x006, 0x000, 0x008, 0x086, 0x000, 0x008, 0x046, 0x000, 0x009, 0x0EC,
            0x050, 0x007, 0x009, 0x000, 0x008, 0x05E, 0x000, 0x008, 0x01E, 0x000, 0x009, 0x09C, 0x054, 0x007, 0x063, 0x000,
            0x008, 0x07E, 0x000, 0x008, 0x03E, 0x000, 0x009, 0x0DC, 0x052, 0x007, 0x01B, 0x000, 0x008, 0x06E, 0x000, 0x008,
            0x02E, 0x000, 0x009, 0x0BC, 0x000, 0x008, 0x00E, 0x000, 0x008, 0x08E, 0x000, 0x008, 0x04E, 0x000, 0x009, 0x0FC,
            0x060, 0x007, 0x100, 0x000, 0x008, 0x051, 0x000, 0x008, 0x011, 0x055, 0x008, 0x083, 0x052, 0x007, 0x01F, 0x000,
            0x008, 0x071, 0x000, 0x008, 0x031, 0x000, 0x009, 0x0C2, 0x050, 0x007, 0x00A, 0x000, 0x008, 0x061, 0x000, 0x008,
            0x021, 0x000, 0x009, 0x0A2, 0x000, 0x008, 0x001, 0x000, 0x008, 0x081, 0x000, 0x008, 0x041, 0x000, 0x009, 0x0E2,
            0x050, 0x007, 0x006, 0x000, 0x008, 0x059, 0x000, 0x008, 0x019, 0x000, 0x009, 0x092, 0x053, 0x007, 0x03B, 0x000,
            0x008, 0x079, 0x000, 0x008, 0x039, 0x000, 0x009, 0x0D2, 0x051, 0x007, 0x011, 0x000, 0x008, 0x069, 0x000, 0x008,
            0x029, 0x000, 0x009, 0x0B2, 0x000, 0x008, 0x009, 0x000, 0x008, 0x089, 0x000, 0x008, 0x049, 0x000, 0x009, 0x0F2,
            0x050, 0x007, 0x004, 0x000, 0x008, 0x055, 0x000, 0x008, 0x015, 0x050, 0x008, 0x102, 0x053, 0x007, 0x02B, 0x000,
            0x008, 0x075, 0x000, 0x008, 0x035, 0x000, 0x009, 0x0CA, 0x051, 0x007, 0x00D, 0x000, 0x008, 0x065, 0x000, 0x008,
            0x025, 0x000, 0x009, 0x0AA, 0x000, 0x008, 0x005, 0x000, 0x008, 0x085, 0x000, 0x008, 0x045, 0x000, 0x009, 0x0EA,
            0x050, 0x007, 0x008, 0x000, 0x008, 0x05D, 0x000, 0x008, 0x01D, 0x000, 0x009, 0x09A, 0x054, 0x007, 0x053, 0x000,
            0x008, 0x07D, 0x000, 0x008, 0x03D, 0x000, 0x009, 0x0DA, 0x052, 0x007, 0x017, 0x000, 0x008, 0x06D, 0x000, 0x008,
            0x02D, 0x000, 0x009, 0x0BA, 0x000, 0x008, 0x00D, 0x000, 0x008, 0x08D, 0x000, 0x008, 0x04D, 0x000, 0x009, 0x0FA,
            0x050, 0x007, 0x003, 0x000, 0x008, 0x053, 0x000, 0x008, 0x013, 0x055, 0x008, 0x0C3, 0x053, 0x007, 0x023, 0x000,
            0x008, 0x073, 0x000, 0x008, 0x033, 0x000, 0x009, 0x0C6, 0x051, 0x007, 0x00B, 0x000, 0x008, 0x063, 0x000, 0x008,
            0x023, 0x000, 0x009, 0x0A6, 0x000, 0x008, 0x003, 0x000, 0x008, 0x083, 0x000, 0x008, 0x043, 0x000, 0x009, 0x0E6,
            0x050, 0x007, 0x007, 0x000, 0x008, 0x05B, 0x000, 0x008, 0x01B, 0x000, 0x009, 0x096, 0x054, 0x007, 0x043, 0x000,
            0x008, 0x07B, 0x000, 0x008, 0x03B, 0x000, 0x009, 0x0D6, 0x052, 0x007, 0x013, 0x000, 0x008, 0x06B, 0x000, 0x008,
            0x02B, 0x000, 0x009, 0x0B6, 0x000, 0x008, 0x00B, 0x000, 0x008, 0x08B, 0x000, 0x008, 0x04B, 0x000, 0x009, 0x0F6,
            0x050, 0x007, 0x005, 0x000, 0x008, 0x057, 0x000, 0x008, 0x017, 0x0C0, 0x008, 0x000, 0x053, 0x007, 0x033, 0x000,
            0x008, 0x077, 0x000, 0x008, 0x037, 0x000, 0x009, 0x0CE, 0x051, 0x007, 0x00F, 0x000, 0x008, 0x067, 0x000, 0x008,
            0x027, 0x000, 0x009, 0x0AE, 0x000, 0x008, 0x007, 0x000, 0x008, 0x087, 0x000, 0x008, 0x047, 0x000, 0x009, 0x0EE,
            0x050, 0x007, 0x009, 0x000, 0x008, 0x05F, 0x000, 0x008, 0x01F, 0x000, 0x009, 0x09E, 0x054, 0x007, 0x063, 0x000,
            0x008, 0x07F, 0x000, 0x008, 0x03F, 0x000, 0x009, 0x0DE, 0x052, 0x007, 0x01B, 0x000, 0x008, 0x06F, 0x000, 0x008,
            0x02F, 0x000, 0x009, 0x0BE, 0x000, 0x008, 0x00F, 0x000, 0x008, 0x08F, 0x000, 0x008, 0x04F, 0x000, 0x009, 0x0FE,
            0x060, 0x007, 0x100, 0x000, 0x008, 0x050, 0x000, 0x008, 0x010, 0x054, 0x008, 0x073, 0x052, 0x007, 0x01F, 0x000,
            0x008, 0x070, 0x000, 0x008, 0x030, 0x000, 0x009, 0x0C1, 0x050, 0x007, 0x00A, 0x000, 0x008, 0x060, 0x000, 0x008,
            0x020, 0x000, 0x009, 0x0A1, 0x000, 0x008, 0x000, 0x000, 0x008, 0x080, 0x000, 0x008, 0x040, 0x000, 0x009, 0x0E1,
            0x050, 0x007, 0x006, 0x000, 0x008, 0x058, 0x000, 0x008, 0x018, 0x000, 0x009, 0x091, 0x053, 0x007, 0x03B, 0x000,
            0x008, 0x078, 0x000, 0x008, 0x038, 0x000, 0x009, 0x0D1, 0x051, 0x007, 0x011, 0x000, 0x008, 0x068, 0x000, 0x008,
            0x028, 0x000, 0x009, 0x0B1, 0x000, 0x008, 0x008, 0x000, 0x008, 0x088, 0x000, 0x008, 0x048, 0x000, 0x009, 0x0F1,
            0x050, 0x007, 0x004, 0x000, 0x008, 0x054, 0x000, 0x008, 0x014, 0x055, 0x008, 0x0E3, 0x053, 0x007, 0x02B, 0x000,
            0x008, 0x074, 0x000, 0x008, 0x034, 0x000, 0x009, 0x0C9, 0x051, 0x007, 0x00D, 0x000, 0x008, 0x064, 0x000, 0x008,
            0x024, 0x000, 0x009, 0x0A9, 0x000, 0x008, 0x004, 0x000, 0x008, 0x084, 0x000, 0x008, 0x044, 0x000, 0x009, 0x0E9,
            0x050, 0x007, 0x008, 0x000, 0x008, 0x05C, 0x000, 0x008, 0x01C, 0x000, 0x009, 0x099, 0x054, 0x007, 0x053, 0x000,
            0x008, 0x07C, 0x000, 0x008, 0x03C, 0x000, 0x009, 0x0D9, 0x052, 0x007, 0x017, 0x000, 0x008, 0x06C, 0x000, 0x008,
            0x02C, 0x000, 0x009, 0x0B9, 0x000, 0x008, 0x00C, 0x000, 0x008, 0x08C, 0x000, 0x008, 0x04C, 0x000, 0x009, 0x0F9,
            0x050, 0x007, 0x003, 0x000, 0x008, 0x052, 0x000, 0x008, 0x012, 0x055, 0x008, 0x0A3, 0x053, 0x007, 0x023, 0x000,
            0x008, 0x072, 0x000, 0x008, 0x032, 0x000, 0x009, 0x0C5, 0x051, 0x007, 0x00B, 0x000, 0x008, 0x062, 0x000, 0x008,
            0x022, 0x000, 0x009, 0x0A5, 0x000, 0x008, 0x002, 0x000, 0x008, 0x082, 0x000, 0x008, 0x042, 0x000, 0x009, 0x0E5,
            0x050, 0x007, 0x007, 0x000, 0x008, 0x05A, 0x000, 0x008, 0x01A, 0x000, 0x009, 0x095, 0x054, 0x007, 0x043, 0x000,
            0x008, 0x07A, 0x000, 0x008, 0x03A, 0x000, 0x009, 0x0D5, 0x052, 0x007, 0x013, 0x000, 0x008, 0x06A, 0x000, 0x008,
            0x02A, 0x000, 0x009, 0x0B5, 0x000, 0x008, 0x00A, 0x000, 0x008, 0x08A, 0x000, 0x008, 0x04A, 0x000, 0x009, 0x0F5,
            0x050, 0x007, 0x005, 0x000, 0x008, 0x056, 0x000, 0x008, 0x016, 0x0C0, 0x008, 0x000, 0x053, 0x007, 0x033, 0x000,
            0x008, 0x076, 0x000, 0x008, 0x036, 0x000, 0x009, 0x0CD, 0x051, 0x007, 0x00F, 0x000, 0x008, 0x066, 0x000, 0x008,
            0x026, 0x000, 0x009, 0x0AD, 0x000, 0x008, 0x006, 0x000, 0x008, 0x086, 0x000, 0x008, 0x046, 0x000, 0x009, 0x0ED,
            0x050, 0x007, 0x009, 0x000, 0x008, 0x05E, 0x000, 0x008, 0x01E, 0x000, 0x009, 0x09D, 0x054, 0x007, 0x063, 0x000,
            0x008, 0x07E, 0x000, 0x008, 0x03E, 0x000, 0x009, 0x0DD, 0x052, 0x007, 0x01B, 0x000, 0x008, 0x06E, 0x000, 0x008,
            0x02E, 0x000, 0x009, 0x0BD, 0x000, 0x008, 0x00E, 0x000, 0x008, 0x08E, 0x000, 0x008, 0x04E, 0x000, 0x009, 0x0FD,
            0x060, 0x007, 0x100, 0x000, 0x008, 0x051, 0x000, 0x008, 0x011, 0x055, 0x008, 0x083, 0x052, 0x007, 0x01F, 0x000,
            0x008, 0x071, 0x000, 0x008, 0x031, 0x000, 0x009, 0x0C3, 0x050, 0x007, 0x00A, 0x000, 0x008, 0x061, 0x000, 0x008,
            0x021, 0x000, 0x009, 0x0A3, 0x000, 0x008, 0x001, 0x000, 0x008, 0x081, 0x000, 0x008, 0x041, 0x000, 0x009, 0x0E3,
            0x050, 0x007, 0x006, 0x000, 0x008, 0x059, 0x000, 0x008, 0x019, 0x000, 0x009, 0x093, 0x053, 0x007, 0x03B, 0x000,
            0x008, 0x079, 0x000, 0x008, 0x039, 0x000, 0x009, 0x0D3, 0x051, 0x007, 0x011, 0x000, 0x008, 0x069, 0x000, 0x008,
            0x029, 0x000, 0x009, 0x0B3, 0x000, 0x008, 0x009, 0x000, 0x008, 0x089, 0x000, 0x008, 0x049, 0x000, 0x009, 0x0F3,
            0x050, 0x007, 0x004, 0x000, 0x008, 0x055, 0x000, 0x008, 0x015, 0x050, 0x008, 0x102, 0x053, 0x007, 0x02B, 0x000,
            0x008, 0x075, 0x000, 0x008, 0x035, 0x000, 0x009, 0x0CB, 0x051, 0x007, 0x00D, 0x000, 0x008, 0x065, 0x000, 0x008,
            0x025, 0x000, 0x009, 0x0AB, 0x000, 0x008, 0x005, 0x000, 0x008, 0x085, 0x000, 0x008, 0x045, 0x000, 0x009, 0x0EB,
            0x050, 0x007, 0x008, 0x000, 0x008, 0x05D, 0x000, 0x008, 0x01D, 0x000, 0x009, 0x09B, 0x054, 0x007, 0x053, 0x000,
            0x008, 0x07D, 0x000, 0x008, 0x03D, 0x000, 0x009, 0x0DB, 0x052, 0x007, 0x017, 0x000, 0x008, 0x06D, 0x000, 0x008,
            0x02D, 0x000, 0x009, 0x0BB, 0x000, 0x008, 0x00D, 0x000, 0x008, 0x08D, 0x000, 0x008, 0x04D, 0x000, 0x009, 0x0FB,
            0x050, 0x007, 0x003, 0x000, 0x008, 0x053, 0x000, 0x008, 0x013, 0x055, 0x008, 0x0C3, 0x053, 0x007, 0x023, 0x000,
            0x008, 0x073, 0x000, 0x008, 0x033, 0x000, 0x009, 0x0C7, 0x051, 0x007, 0x00B, 0x000, 0x008, 0x063, 0x000, 0x008,
            0x023, 0x000, 0x009, 0x0A7, 0x000, 0x008, 0x003, 0x000, 0x008, 0x083, 0x000, 0x008, 0x043, 0x000, 0x009, 0x0E7,
            0x050, 0x007, 0x007, 0x000, 0x008, 0x05B, 0x000, 0x008, 0x01B, 0x000, 0x009, 0x097, 0x054, 0x007, 0x043, 0x000,
            0x008, 0x07B, 0x000, 0x008, 0x03B, 0x000, 0x009, 0x0D7, 0x052, 0x007, 0x013, 0x000, 0x008, 0x06B, 0x000, 0x008,
            0x02B, 0x000, 0x009, 0x0B7, 0x000, 0x008, 0x00B, 0x000, 0x008, 0x08B, 0x000, 0x008, 0x04B, 0x000, 0x009, 0x0F7,
            0x050, 0x007, 0x005, 0x000, 0x008, 0x057, 0x000, 0x008, 0x017, 0x0C0, 0x008, 0x000, 0x053, 0x007, 0x033, 0x000,
            0x008, 0x077, 0x000, 0x008, 0x037, 0x000, 0x009, 0x0CF, 0x051, 0x007, 0x00F, 0x000, 0x008, 0x067, 0x000, 0x008,
            0x027, 0x000, 0x009, 0x0AF, 0x000, 0x008, 0x007, 0x000, 0x008, 0x087, 0x000, 0x008, 0x047, 0x000, 0x009, 0x0EF,
            0x050, 0x007, 0x009, 0x000, 0x008, 0x05F, 0x000, 0x008, 0x01F, 0x000, 0x009, 0x09F, 0x054, 0x007, 0x063, 0x000,
            0x008, 0x07F, 0x000, 0x008, 0x03F, 0x000, 0x009, 0x0DF, 0x052, 0x007, 0x01B, 0x000, 0x008, 0x06F, 0x000, 0x008,
            0x02F, 0x000, 0x009, 0x0BF, 0x000, 0x008, 0x00F, 0x000, 0x008, 0x08F, 0x000, 0x008, 0x04F, 0x000, 0x009, 0x0FF
        };
        private bool FastInflate()
        {
            int DMask = InflationMask[DBitsPerBranch], LMask = InflationMask[LBitsPerBranch], RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
            do
            {
                while (BlocksDecoder.BitBufferShift < 20)
                {
                    BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                    BlocksDecoder.BitBufferShift += 8;
                }
                int Offset = BlocksDecoder.BitBuffer & LMask, TreeBaseIndex = (LTreeIndex + Offset) * 3, ExtraBits = LTree[TreeBaseIndex];
                if (ExtraBits == 0)
                {
                    int Shift = LTree[++TreeBaseIndex];
                    BlocksDecoder.BitBuffer >>= Shift;
                    BlocksDecoder.BitBufferShift -= Shift;
                    BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = (byte)LTree[++TreeBaseIndex];
                    RemainingBytes--;
                }
                else
                    for (;;)
                    {
                        int Shift = LTree[++TreeBaseIndex];
                        BlocksDecoder.BitBuffer >>= Shift;
                        BlocksDecoder.BitBufferShift -= Shift;
                        if ((ExtraBits & 16) != 0)
                        {
                            ExtraBits &= 15;
                            int CopyLength = LTree[++TreeBaseIndex] + (BlocksDecoder.BitBuffer & InflationMask[ExtraBits]);
                            BlocksDecoder.BitBuffer >>= ExtraBits;
                            BlocksDecoder.BitBufferShift -= ExtraBits;
                            while (BlocksDecoder.BitBufferShift < 15)
                            {
                                BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                                BlocksDecoder.BitBufferShift += 8;
                            }
                            Offset = BlocksDecoder.BitBuffer & DMask;
                            ExtraBits = DTree[TreeBaseIndex = (DTreeIndex + Offset) * 3];
                            for (;;)
                            {
                                Shift = DTree[++TreeBaseIndex];
                                BlocksDecoder.BitBuffer >>= Shift;
                                BlocksDecoder.BitBufferShift -= Shift;
                                if ((ExtraBits & 16) != 0)
                                {
                                    ExtraBits &= 15;
                                    while (BlocksDecoder.BitBufferShift < ExtraBits)
                                    {
                                        BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                                        BlocksDecoder.BitBufferShift += 8;
                                    }
                                    int Distance = DTree[++TreeBaseIndex] + (BlocksDecoder.BitBuffer & InflationMask[ExtraBits]);
                                    BlocksDecoder.BitBuffer >>= ExtraBits;
                                    BlocksDecoder.BitBufferShift -= ExtraBits;
                                    RemainingBytes -= CopyLength;
                                    int CopyIndex = BlocksDecoder.WriteOffset - Distance;
                                    if (BlocksDecoder.WriteOffset < Distance)
                                    {
                                        do
                                            CopyIndex += 32768;
                                        while (CopyIndex < 0);
                                        if (CopyLength > (ExtraBits = 32768 - CopyIndex))
                                        {
                                            CopyLength -= ExtraBits;
                                            Copy(BlocksDecoder.Window, CopyIndex, BlocksDecoder.Window, BlocksDecoder.WriteOffset, ExtraBits);
                                            BlocksDecoder.WriteOffset += ExtraBits;
                                            CopyIndex = 0;
                                        }
                                    }
                                    else
                                    {
                                        BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = BlocksDecoder.Window[CopyIndex++];
                                        BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = BlocksDecoder.Window[CopyIndex++];
                                        CopyLength -= 2;
                                    }
                                    for (; CopyLength > 0; CopyLength--)
                                        BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = BlocksDecoder.Window[CopyIndex++];
                                    break;
                                }
                                else if ((ExtraBits & 64) == 0)
                                {
                                    Offset += DTree[++TreeBaseIndex] + (BlocksDecoder.BitBuffer & InflationMask[ExtraBits]);
                                    ExtraBits = DTree[TreeBaseIndex = (DTreeIndex + Offset) * 3];
                                }
                                else
                                    throw new ValidatorException("Failed to decompress mod files");
                            }
                            break;
                        }
                        if ((ExtraBits & 64) == 0)
                        {
                            Offset += LTree[++TreeBaseIndex] + (BlocksDecoder.BitBuffer & InflationMask[ExtraBits]);
                            if ((ExtraBits = LTree[TreeBaseIndex = (LTreeIndex + Offset) * 3]) == 0)
                            {
                                Shift = LTree[++TreeBaseIndex];
                                BlocksDecoder.BitBuffer >>= Shift;
                                BlocksDecoder.BitBufferShift -= Shift;
                                BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = (byte)LTree[++TreeBaseIndex];
                                RemainingBytes--;
                                break;
                            }
                        }
                        else if ((ExtraBits & 32) != 0)
                        {
                            int BytesDiscarded1 = BlocksDecoder.BitBufferShift >> 3;
                            if (BytesDiscarded1 > 0)
                                BytesDiscarded1 = 0;
                            BlocksDecoder.BitBufferShift -= BytesDiscarded1 << 3;
                            BlocksDecoder.Decompressor.InputAvailableSize += BytesDiscarded1;
                            BlocksDecoder.Decompressor.Reader.Position -= BytesDiscarded1;
                            return true;
                        }
                        else
                            throw new ValidatorException("Failed to decompress mod files");
                    }
            }
            while (RemainingBytes > 257 && BlocksDecoder.Decompressor.InputAvailableSize > 9);
            int BytesDiscarded = BlocksDecoder.BitBufferShift >> 3;
            if (BytesDiscarded > 0)
                BytesDiscarded = 0;
            BlocksDecoder.BitBufferShift -= BytesDiscarded << 3;
            BlocksDecoder.Decompressor.InputAvailableSize += BytesDiscarded;
            BlocksDecoder.Decompressor.Reader.Position -= BytesDiscarded;
            return false;
        }
        internal void Initialize()
        {
            DBitsPerBranch = 5;
            LBitsPerBranch = 9;
            LTreeIndex = DTreeIndex = 0;
            DTree = FixedDTree;
            LTree = FixedLTree;
        }
        internal void Initialize(int DBPB, int LBPB, int DTIndex, int LTIndex, int[] Trees)
        {
            DBitsPerBranch = DBPB;
            LBitsPerBranch = LBPB;
            DTreeIndex = DTIndex;
            LTreeIndex = LTIndex;
            DTree = LTree = Trees;
        }
        internal void Decode()
        {
            int RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
            for (;;)
            {
                int Flag;
                if (RemainingBytes > 257 && BlocksDecoder.Decompressor.InputAvailableSize > 9)
                {
                    if (FastInflate())
                        break;
                    else
                        RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                }
                int BaseTreeIndex = LTreeIndex, BitsNeeded = LBitsPerBranch;
                for(;;)
                {
                    while (BlocksDecoder.BitBufferShift < BitsNeeded)
                    {
                        BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                        BlocksDecoder.BitBufferShift += 8;
                    }
                    int TreeIndex = (BaseTreeIndex + (BlocksDecoder.BitBuffer & InflationMask[BitsNeeded])) * 3, State = LTree[TreeIndex++], Shift = LTree[TreeIndex++];
                    BlocksDecoder.BitBuffer >>= Shift;
                    BlocksDecoder.BitBufferShift -= Shift;
                    if (State == 0)
                    {
                        if (RemainingBytes == 0)
                        {
                            if (BlocksDecoder.WriteOffset == 32768 && BlocksDecoder.ReadOffset != 0)
                            {
                                BlocksDecoder.WriteOffset = 0;
                                RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                            }
                            if (RemainingBytes == 0)
                            {
                                BlocksDecoder.Flush();
                                RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                                if (BlocksDecoder.WriteOffset == 32768 && BlocksDecoder.ReadOffset != 0)
                                {
                                    BlocksDecoder.WriteOffset = 0;
                                    RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                                }
                            }
                        }
                        BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = (byte)LTree[TreeIndex];
                        RemainingBytes--;
                        Flag = 1;
                        break;
                    }
                    else if ((State & 16) != 0)
                    {
                        int BitsToGet = State & 15;
                        while (BlocksDecoder.BitBufferShift < BitsToGet)
                        {
                            BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                            BlocksDecoder.BitBufferShift += 8;
                        }
                        Length += LTree[TreeIndex] + (BlocksDecoder.BitBuffer & InflationMask[BitsToGet]);
                        BlocksDecoder.BitBuffer >>= BitsToGet;
                        BlocksDecoder.BitBufferShift -= BitsToGet;
                        BitsNeeded = DBitsPerBranch;
                        BaseTreeIndex = DTreeIndex;
                        for (;;)
                        {
                            while (BlocksDecoder.BitBufferShift < BitsNeeded)
                            {
                                BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                                BlocksDecoder.BitBufferShift += 8;
                            }
                            TreeIndex = (BaseTreeIndex + (BlocksDecoder.BitBuffer & InflationMask[BitsNeeded])) * 3;
                            State = DTree[TreeIndex++];
                            BlocksDecoder.BitBuffer >>= Shift = DTree[TreeIndex++];
                            BlocksDecoder.BitBufferShift -= Shift;
                            if ((State & 16) != 0)
                            {
                                BitsToGet = State & 15;
                                while (BlocksDecoder.BitBufferShift < BitsToGet)
                                {
                                    BlocksDecoder.BitBuffer |= BlocksDecoder.ReadByte() << BlocksDecoder.BitBufferShift;
                                    BlocksDecoder.BitBufferShift += 8;
                                }
                                Distance = DTree[TreeIndex] + (BlocksDecoder.BitBuffer & InflationMask[BitsToGet]);
                                BlocksDecoder.BitBuffer >>= BitsToGet;
                                BlocksDecoder.BitBufferShift -= BitsToGet;
                                int CopyIndex = BlocksDecoder.WriteOffset - Distance;
                                while (CopyIndex < 0)
                                    CopyIndex += 32768;
                                while (Length != 0)
                                {
                                    if (RemainingBytes == 0)
                                    {
                                        if (BlocksDecoder.WriteOffset == 32768 && BlocksDecoder.ReadOffset != 0)
                                        {
                                            BlocksDecoder.WriteOffset = 0;
                                            RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                                        }
                                        if (RemainingBytes == 0)
                                        {
                                            BlocksDecoder.Flush();
                                            RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                                            if (BlocksDecoder.WriteOffset == 32768 && BlocksDecoder.ReadOffset != 0)
                                            {
                                                BlocksDecoder.WriteOffset = 0;
                                                RemainingBytes = BlocksDecoder.WriteOffset < BlocksDecoder.ReadOffset ? BlocksDecoder.ReadOffset - BlocksDecoder.WriteOffset - 1 : 32768 - BlocksDecoder.WriteOffset;
                                            }
                                        }
                                    }
                                    BlocksDecoder.Window[BlocksDecoder.WriteOffset++] = BlocksDecoder.Window[CopyIndex++];
                                    RemainingBytes--;
                                    if (CopyIndex == 32768)
                                        CopyIndex = 0;
                                    Length--;
                                }
                                Flag = 1;
                                break;
                            }
                            else if ((State & 64) == 0)
                            {
                                BitsNeeded = State;
                                BaseTreeIndex = (TreeIndex - 2) / 3 + DTree[TreeIndex];
                            }
                            else
                                throw new ValidatorException("Failed to decompress mod files");
                        }
                        if (Flag == 1)
                            break;
                    }
                    else if ((State & 64) == 0)
                    {
                        BitsNeeded = State;
                        BaseTreeIndex = (TreeIndex - 2) / 3 + LTree[TreeIndex];
                    }
                    else if ((State & 32) != 0)
                    {
                        Flag = 2;
                        break;
                    }
                    else
                        throw new ValidatorException("Failed to decompress mod files");
                }
                if (Flag == 1)
                    continue;
                else if (Flag == 2)
                    break;
            }
            if (BlocksDecoder.BitBufferShift > 7)
            {
                BlocksDecoder.BitBufferShift -= 8;
                BlocksDecoder.Decompressor.InputAvailableSize++;
                BlocksDecoder.Decompressor.Reader.Position--;
            }
            BlocksDecoder.Flush();
        }
    }
}